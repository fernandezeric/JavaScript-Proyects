<!DOCTYPE html>
<!-- Grande Midu -->
<title> Breakout full JS </title>

<style>
   body {
    background-color: #4e4e4e;
   }

   canvas {
      border: 3px solid rgba(255, 166, 0, 0.719);
      border-bottom: transparent;
      border-radius: 4px;
      background: url('./assets/background.png');
      margin: 0 auto;
      display: block;
   }
</style>

<canvas></canvas>

<img hidden id="sprite" src="./assets/sprite.png" alt="Sprite Arkanoid" />
<img hidden id="bricks" src="./assets/bricks.png" alt="Sprite Bricks Arkanoid" />

<script>
   const canvas = document.querySelector('canvas')
   const ctx = canvas.getContext('2d')

   const $sprite = document.querySelector('#sprite')
   const $bricks = document.querySelector('#bricks')

   canvas.width = 720
   canvas.height = 480

   const ballRadius = 3

   let ballX = canvas.width/2
   let ballY = canvas.height - 30
   let ballDx = 3
   let ballDy = -3

   const paddleHeight = 10
   const paddleWidth = 50

   let paddleX = (canvas.width - paddleWidth) / 2
   let paddleY = canvas.height - paddleHeight - 10

   let rightPressed = false
   let leftPressed = false

   const brickRowCount = 6
   const brickColumnCount = 13
   const brickWidth = 32
   const brickHeight = 16
   const brickPadding = 0
   const brickOffsetTop = canvas.width * 0.1
   const brickOffsetLeft = canvas.width * 0.23 // ver que quede al medio
   const bricks = []
   
   const BRICK_STATUS = {
    ACTIVE: 1,
    DESTROYED: 0
   }

   for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = []
    for (let r = 0; r < brickRowCount; r++) {
      const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft
      const brickY = r * (brickHeight + brickPadding) + brickOffsetTop
      const random = Math.floor(Math.random() * 8)

      bricks[c][r] = {
        x: brickX,
        y: brickY,
        status: BRICK_STATUS.ACTIVE,
        color: random
      }
    }
  }

   function drawBall() {
      ctx.beginPath()
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2)
      ctx.fillStyle = '#ff6d91'
      ctx.fill()
      ctx.closePath()
   }

   function drawPaddle() {
      //ctx.fillStyle = '#09f'
      // ctx.fillRect(
      //    paddleX,
      //    paddleY,
      //    paddleWidth,
      //    paddleHeight
      // )

      ctx.drawImage( // que terrible dibujar así
         $sprite, // imagen
         29, // clipX: coordenadas de recorte
         174, // clipY: coordenadas de recorte
         paddleWidth, // el tamaño del recorte
         paddleHeight, // tamaño del recorte
         paddleX, // posición X del dibujo
         paddleY, // posición Y del dibujo
         paddleWidth, // ancho del dibujo
         paddleHeight // alto del dibujo
      )
   }

   function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        const currentBrick = bricks[c][r]
        if (currentBrick.status === BRICK_STATUS.DESTROYED) continue;

        const clipX = currentBrick.color * 32

        ctx.drawImage(
          $bricks,
          clipX,
          0,
          brickWidth,
          brickHeight,
          currentBrick.x,
          currentBrick.y,
          brickWidth,
          brickHeight
        )
      }
    }
  }

   function collisionDetaction() {
      for (let c = 0; c < brickColumnCount; c++) {
         for (let r = 0; r < brickRowCount; r++) {
            const currentBrick = bricks[c][r]
            if (currentBrick.status === BRICK_STATUS.DESTROYED) continue;

            const isBallSameXAsBrick =
               ballX > currentBrick.x &&
               ballX < currentBrick.x + brickWidth

            const isBallSameYAsBrick =
               ballY > currentBrick.y &&
               ballY < currentBrick.y + brickHeight

            if (isBallSameXAsBrick && isBallSameYAsBrick) {
               ballDy = -ballDy
               currentBrick.status = BRICK_STATUS.DESTROYED
            }
         }
    }
   }

   function ballMovement() {
      // lateral collition
      if (
         ballX + ballDx > canvas.width - ballRadius ||
         ballX + ballDx < ballRadius
      ) {
         ballDx *= -1
      }

      if (ballY + ballDy < ballRadius) {
         ballDy *= -1
      }

      const isBallSameXAsPaddle =
         ballX > paddleX &&
         ballX < paddleX + paddleWidth

      const isBallTouchingPaddle =
         ballY + ballDy > paddleY
   
      if (
         isBallSameXAsPaddle &&
         isBallTouchingPaddle
      ) {
         ballDy *= -1
      }
      else if (ballY + ballDy > canvas.height - ballRadius) {
         console.log('Game Over')
         document.location.reload()
      }
      ballX += ballDx
      ballY += ballDy
   }

   function paddleMovement() {
      if (rightPressed && paddleX < canvas.width - paddleWidth) {
         paddleX += 7
      } else if (leftPressed && paddleX > 0) {
         paddleX -= 7
      }
   }
   
   function cleanCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
   }

   function initEvents () {
      document.addEventListener('keydown', keyDownHandler)
      document.addEventListener('keyup', keyUpHandler)

      function keyDownHandler (event) {
         const { key } = event
         if ( key === 'Right' || key === 'ArrowRight') {
            rightPressed = true
         } else if (key === 'Left' || key === 'ArrowLeft') {
            leftPressed = true
         }
      }

      function keyUpHandler (event) {
         const { key } = event
         if ( key === 'Right' || key === 'ArrowRight') {
            rightPressed = false
         } else if (key === 'Left' || key === 'ArrowLeft') {
            leftPressed = false
         }
      }
   }

   function draw() {
      cleanCanvas()
      // draws and checks collitions

      drawBall()
      drawPaddle()
      drawBricks()
      // drawScore()

      collisionDetaction()
      ballMovement()
      paddleMovement()

      window.requestAnimationFrame(draw)
   }

   draw()
   initEvents()
</script>